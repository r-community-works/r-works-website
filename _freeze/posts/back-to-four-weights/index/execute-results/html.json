{
  "hash": "8d2bbd4721c62b30efe0dadb4836e2f1",
  "result": {
    "markdown": "---\ntitle: \"Writing Signed Trinary: or, Back To the Four Weights Problem\"\nauthor: \"Nina Zumel\"\ndate: 2024-12-13\ndescription: \"Let's run some modular arithmetic using R.\"\nimage: four-weights.jpg\nimage-alt: \"A balance scale and four weights. Source: Internet Archive\"\ncategories: \"Puzzle Corner\"\n---\n\n\nRecently on Puzzle Corner, we looked at the [Four Weights problem](https://rworks.dev/posts/four-weights/): what are the four weights that can weigh any object $x$ in the (integer) range 1 to 40 on a balance scale?\n\n![A balance scale and four weights](four-weights.jpg){fig-alt=\"A balance scale and four weights. source: Internet Archive\"}\n\nThe puzzle just asks you to find the values of the weights, which are $(1, 3, 9, 27)$. But *how* do you weigh $x$---that is, with (a known) $x$ in the right-hand pan of the scale, how do you determine the distribution of weights so that the scale balances?\n\nThis isn't a practical question, since if I know $x$, then I don't have to weigh the object. But thinking about the solution brings up a cute little observation about modular arithmetic, and so it felt worth a short writeup. The solution is based on a standard procedure for converting decimal values to a base-$n$ representation. If you are familiar with that procedure, you can skim the next section and/or skip to [this section](https://rworks.dev/posts/back-to-four-weights/#converting-x-to-signed-trinary). Otherwise, read on.\n\n## Converting $x$ to a base-n representation\n\nAssume you want to represent a nonnegative integer with up to $m$ digits in binary.\nRecall that $m$ binary digits can represent any number in the range $0 : (2^m - 1)$.\nThis is the pseudo-code.\n\n```\ni = 1        # initialize the index\nr = zeros(m) # all-zeros vector of length m\nif x >= 2^m then throw(\"x is out of range\")\n\nwhile x > 0\n  d = floor(x/2)\n  r[i] = x mod 2\n  x = d\n  i = i+1\n  \nreturn reverse(r)  # so lowest value digit is rightmost\n```\n\nLet's do it by hand for $x = 13$, using 4 digits (which can represent up to the value $2^4 - 1 =  15$).\n\n```\n13/2 = 6 rem 1 (d = 6, r[1] = 1)\n6/2 = 3 rem 0\n3/2 = 1 rem 1\n1/2 = 0 rem 1\n```\n\nSo we have 13 = 1101 in base-2, or `(1*8) + (1*4) + (0*2) + (1*1)`.\n\nFor an unsigned trinary representation, the idea is the same, only you divide by 3 instead of 2. Let's try it with 18, using 4 digits (which can represent up to the value $3^4 - 1$, which is 80).\n\n```\n18/3 = 6 rem 0\n6/3 = 2 rem 0\n2/3 = 0 rem 2\n```\n\nSo 18 = 0200 in base-3, or `(0*27) + (2*9) + (0*3) + (0*1)`.\n\nWe can write a general function to convert a decimal number `x` to base-n representation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert x to its unsigned base-n representation\n# n: the base\n# ndigits: the maximum number of digits\nbase_n = function(x, n, ndigits) {\n  r = numeric(ndigits)\n  if (x >= n ^ ndigits)\n    stop(\"x is out of range\")\n  i = 1\n  while (x > 0) {\n    d = floor(x / n)\n    r[i] = x %% n\n    x = d\n    i = i + 1\n  }\n  \n  rev(r)\n}\n\n# convert from unsigned base-n back to decimal\nto_decimal = function(r, n) {\n  r = rev(r) # put the lowest digit to the leftmost\n  ndigits = length(r)\n  x = 0\n  for (i in 1:ndigits)\n    x = x + r[i] * n ^ (i - 1)\n  \n  x\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert 13 to binary\nr = base_n(13, 2, 4)\n# confirm this is 13\nstopifnot(to_decimal(r, 2) == 13)\nr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 0 1\n```\n:::\n\n```{.r .cell-code}\n# convert 18 to trinary\nr = base_n(18, 3, 4)\n# confirm this is 18\nstopifnot(to_decimal(r, 3) == 18)\nr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 2 0 0\n```\n:::\n:::\n\n\n## Converting $x$ to signed trinary\n\nRecall that when solving the Four Weights problem, we established that any nonnegative integer value $x$ in the range 1:40 could be represented as\n\n$$\ns_1 w_1 + s_2 w_2 + s_3 w_3 + s_4 w_4 = x.\n$$\n\nwhere the weights $w_i$ are `(1, 3, 9, 27)`---we write it smallest-first, consistently with the previous post on this problem---and $s_i \\in \\{-1, 0, 1\\}$, rather than the $\\{0, 1, 2\\}$ of unsigned trinary. A positive coefficient means the weight goes in the left pan, a negative coefficient means the weight goes in the right pan with $x$, and 0 means the weight isn't used.\n\nThe four digits still represent $3^4 = 81$ unique values, but some of them are now negative. For the Four Weights problem, we are only concerned with nonnegative $x$, of which we can represent zero, plus $(3^4 - 1)/2 = 40$ values---the numbers 1:40. So we'll concentrate on just expressing these nonnegative integers.\n\nTo modify the unsigned trinary conversion to a signed one, we use the observation that\n\n* The equation `x/3 = d rem 2` is equivalent to `x/3 = (d+1) rem -1`. \n\nThis is a bit of an abuse of the notation; but here's an example of what we are trying to say. We know that \n\n* `8/3 = 2 rem 2`, which is the same as saying  `8 = 2*3 + 2`. \n\nAnother way of writing this is \n\n* `8 = (2+1)*3 - 1 = 3*3 - 1` which we'll write as:  `8/3 = 3 rem -1`\n\nSo (when considering only nonnegative $x$) the pseudo-code for the algorithm becomes:\n\n```\ni = 1\nr = zeros(m)\nmaxval = (3^m - 1)/2\nif x > maxval then throw(\"x is out of range\")\n\nwhile x > 0\n  d = floor(x/3)\n  r[i] = x mod 3\n  if r[i]==2\n    d = d+1\n    r[i] = -1\n  x = d\n  i = i+1\n  \nreturn r  # we won't reverse it, to be consistent with our puzzle solution\n\n```\nLet's convert 18 to signed trinary.\n\n```\n18/3 = 6 rem 0\n6/3 = 2 rem 0\n2/3 = 0 rem 2 = 1 rem -1\n1/3 = 0 rem 1\n```\n\nSo 18 codes to [0 0 -1 1] = `(0*1) + (0*3) + (-1*9) + (1*27)`.\nIn the scale notation that we used while solving the puzzle, we would write this\nas $[\\{27\\} | \\{x, 9\\}]$, meaning the 27-weight is in the left pan, and the 9-weight is in the\nright pan with $x$.\n\nHere's the code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert nonnegative x to signed trinary\nweigh = function(x) {\n  if (x > 40)\n    stop(\"x out of range\")\n  r = numeric(4)\n  i = 1\n  while (x > 0) {\n    d = floor(x / 3)\n    r[i] = x %% 3\n    if (r[i] == 2) {\n      d = d + 1\n      r[i] = -1\n    }\n    x = d\n    i = i + 1\n  }\n  r\n}\n\n# write the signed trinary representation in our scale notation\nscale_notation = function(signs) {\n  w = c(1, 3, 9, 27)\n  lefti = which(signs > 0)\n  righti = which(signs < 0)\n  \n  leftset = paste(w[lefti], collapse = \", \")\n  if (length(righti) > 0)\n    rightset = paste(\"x,\", paste(w[righti], collapse = \", \"))\n  else\n    rightset = \"x\"\n  \n  notation = paste(\"[ {\", leftset, \"} | {\", rightset, \"} ]\")\n  notation\n}\n\n# convert signed trinary back to decimal\nto_x = function(signs) {\n  w = c(1, 3, 9, 27)\n  x = sum(w * signs) # dot product of w and signs\n}\n```\n:::\n\n\nLet's try a few.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 18\nsigns = weigh(x)\n# convert back and check it's the same number\nstopifnot(x == to_x(signs))\nscale_notation(signs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"[ { 27 } | { x, 9 } ]\"\n```\n:::\n\n```{.r .cell-code}\nx = 35\nsigns = weigh(x)\nstopifnot(x == to_x(signs))\nscale_notation(signs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"[ { 9, 27 } | { x, 1 } ]\"\n```\n:::\n\n```{.r .cell-code}\nx = 15\nsigns = weigh(x)\nstopifnot(x == to_x(signs))\nscale_notation(signs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"[ { 27 } | { x, 3, 9 } ]\"\n```\n:::\n\n```{.r .cell-code}\nx = 30\nsigns = weigh(x)\nstopifnot(x == to_x(signs))\nscale_notation(signs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"[ { 3, 27 } | { x } ]\"\n```\n:::\n\n```{.r .cell-code}\nx = 4\nsigns = weigh(x)\nstopifnot(x == to_x(signs))\nscale_notation(signs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"[ { 1, 3 } | { x } ]\"\n```\n:::\n:::\n\n\nSo now we can weigh objects we know the weight of. Hurrah? But I still think it's cute.\n\n*Nina Zumel is a data scientist based in San Francisco, with 20+ years of experience in machine learning, statistics, and analytics. She is the co-founder of the data science consulting firm Win-Vector LLC, and (with John Mount) the co-author of Practical Data Science with R, now in its second edition.*",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}